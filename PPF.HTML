<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Production Possibilities Frontier Model</title>
<style>
    :root {
        --curve-color: #012169;
        --shift-color: #A4AFB9;
        --point-a-color: #d9534f;
        --point-b-color: #5cb85c;
        --inefficient-bg: #e6f0ff;
        --bg-color: #f4f4f9;
        --sidebar-bg: #ffffff;
        --border-color: #ddd;
    }
    body, html {
        margin: 0; padding: 0; height: 100%; font-family: system-ui, -apple-system, sans-serif;
        display: flex; background: var(--bg-color); color: #333; overflow: hidden;
    }
    .sidebar {
        width: 320px; min-width: 320px; background: var(--sidebar-bg); border-right: 1px solid var(--border-color);
        padding: 20px; overflow-y: auto; box-sizing: border-box; display: flex; flex-direction: column; gap: 15px;
    }
    .main {
        flex-grow: 1; display: flex; flex-direction: column; padding: 20px; box-sizing: border-box; position: relative; width: 1500px;
    }
    h2, h3 { margin: 0 0 10px 0; font-size: 1.1em; border-bottom: 1px solid var(--border-color); padding-bottom: 5px; }
    .control-group { display: flex; flex-direction: column; gap: 5px; margin-bottom: 15px; }
    .control-row { display: flex; justify-content: space-between; align-items: center; }
    input[type="number"], input[type="text"], select { width: 80px; padding: 4px; border: 1px solid #ccc; border-radius: 4px; }
    input[type="text"].full-width { width: 100%; box-sizing: border-box; margin-bottom: 5px; }
    select { width: 100%; margin-bottom: 5px; padding: 6px; }
    input[type="range"] { flex-grow: 1; margin: 0 10px; }
    input[type="color"] { border: none; width: 30px; height: 30px; padding: 0; cursor: pointer; }
    button { padding: 8px 12px; background: #0056b3; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; }
    button:hover { background: #004494; }
    .header-controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
    #chartTitleDisplay { font-size: 1.5em; font-weight: bold; margin: 0; }
    canvas { background: white; border: 1px solid var(--border-color); border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); width: 100%; height: 100%; display: block; cursor: crosshair; }
    table { width: 100%; border-collapse: collapse; font-size: 0.9em; }
    th, td { border: 1px solid var(--border-color); padding: 5px; text-align: left; }
    th { background: #f9f9f9; }
    .hidden { display: none !important; }
    .note { font-size: 0.8em; color: #666; margin-top: -5px; margin-bottom: 5px;}
</style>
</head>
<body>

<div class="sidebar">
    <div class="control-group">
        <h3>1. General</h3>
        <input type="text" id="chartTitle" class="full-width" value="Production Possibilities Frontier">
        <div class="control-row"><label>Good X (Horizontal):</label> <input type="text" id="labelX" value="Capital Goods"></div>
        <div class="control-row"><label>Good Y (Vertical):</label> <input type="text" id="labelY" value="Consumer Goods"></div>
    </div>

    <div class="control-group">
        <h3>2. Shape & Intercepts</h3>
        <select id="ppfShape">
            <option value="curved">Curved (Increasing Opp. Cost)</option>
            <option value="straight">Straight (Constant Opp. Cost)</option>
            <option value="custom">Custom Formula</option>
        </select>
        <div id="customFormulaGroup" class="hidden">
            <div class="note">Variables available: <code>x</code>, <code>maxX</code>, <code>maxY</code></div>
            <input type="text" id="customEq" class="full-width" value="maxY - (x * x) / (maxX * maxX) * maxY">
        </div>
        <div class="control-row"><label>Max X Intercept:</label> <input type="number" id="maxX" min="10" max="1000" value="100"></div>
        <div class="control-row"><label>Max Y Intercept:</label> <input type="number" id="maxY" min="10" max="1000" value="100"></div>
    </div>

    <div class="control-group">
        <h3>3. Economic Growth (Shift)</h3>
        <div class="control-row"><label>Tech Shift X (%):</label> <input type="range" id="shiftX" min="-50" max="100" step="1" value="0"> <input type="number" id="shiftXNum" value="0"></div>
        <div class="control-row"><label>Tech Shift Y (%):</label> <input type="range" id="shiftY" min="-50" max="100" step="1" value="0"> <input type="number" id="shiftYNum" value="0"></div>
    </div>

    <div class="control-group">
        <h3>4. Production Points</h3>
        <div class="note">Points can be dragged directly on the canvas.</div>
        <div class="control-row" style="color: var(--point-a-color); font-weight: bold;"><label>Point A (X, Y):</label> 
            <input type="number" id="ptAX" value="40" style="width:50px;"> <input type="number" id="ptAY" value="91.6" style="width:50px;" step="0.1">
        </div>
        <div class="control-row" style="color: var(--point-b-color); font-weight: bold;"><label>Point B (X, Y):</label> 
            <input type="number" id="ptBX" value="80" style="width:50px;"> <input type="number" id="ptBY" value="60" style="width:50px;" step="0.1">
        </div>
    </div>

    <div class="control-group">
        <h3>5. Style</h3>
        <div class="control-row"><label><input type="checkbox" id="showShading" checked> Show Inefficiency Shading</label></div>
        <div class="control-row" style="margin-top: 5px;">
            <label>PPF Line</label><input type="color" id="colPPF" value="#012169">
            <label>Shifted</label><input type="color" id="colShift" value="#A4AFB9">
        </div>
    </div>

    <div class="control-group">
        <h3>6. Statistics</h3>
        <table>
            <tr><th colspan="2" style="background: #f1f1f1; text-align: center;">Point Analysis</th></tr>
            <tr><th style="color: var(--point-a-color);">Status A</th><td id="statA">Efficient</td></tr>
            <tr><th style="color: var(--point-b-color);">Status B</th><td id="statB">Efficient</td></tr>
            <tr><th colspan="2" style="background: #f1f1f1; text-align: center;">Opportunity Cost (A &rarr; B)</th></tr>
            <tr><th>Gain</th><td id="statGain">0</td></tr>
            <tr><th>Loss</th><td id="statLoss">0</td></tr>
        </table>
    </div>
</div>

<div class="main">
    <div class="header-controls">
        <h2 id="chartTitleDisplay">Production Possibilities Frontier</h2>
        <button id="btnDownload">Download PNG</button>
    </div>
    <div style="flex-grow: 1; position: relative;" id="canvasContainer">
        <canvas id="ppfCanvas"></canvas>
    </div>
</div>

<script>
    const canvas = document.getElementById('ppfCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('canvasContainer');
    let renderRequested = false;

    // Drag State
    let isDragging = false;
    let dragTarget = null; // 'A' or 'B'
    let canvasProj = { padLeft: 0, padTop: 0, size: 0, maxData: 100 };

    const els = {
        title: document.getElementById('chartTitle'),
        titleDisplay: document.getElementById('chartTitleDisplay'),
        labelX: document.getElementById('labelX'), labelY: document.getElementById('labelY'),
        ppfShape: document.getElementById('ppfShape'),
        customFormulaGroup: document.getElementById('customFormulaGroup'), customEq: document.getElementById('customEq'),
        maxX: document.getElementById('maxX'), maxY: document.getElementById('maxY'),
        shiftX: document.getElementById('shiftX'), shiftXNum: document.getElementById('shiftXNum'),
        shiftY: document.getElementById('shiftY'), shiftYNum: document.getElementById('shiftYNum'),
        ptAX: document.getElementById('ptAX'), ptAY: document.getElementById('ptAY'),
        ptBX: document.getElementById('ptBX'), ptBY: document.getElementById('ptBY'),
        showShading: document.getElementById('showShading'),
        colPPF: document.getElementById('colPPF'), colShift: document.getElementById('colShift'),
        statA: document.getElementById('statA'), statB: document.getElementById('statB'),
        statGain: document.getElementById('statGain'), statLoss: document.getElementById('statLoss')
    };

    function sync(slider, num) {
        slider.addEventListener('input', () => { num.value = slider.value; requestRender(); });
        num.addEventListener('input', () => { slider.value = num.value; requestRender(); });
    }

    sync(els.shiftX, els.shiftXNum); sync(els.shiftY, els.shiftYNum);

    [els.title, els.labelX, els.labelY, els.ppfShape, els.customEq, els.maxX, els.maxY, 
     els.ptAX, els.ptAY, els.ptBX, els.ptBY, els.showShading, els.colPPF, els.colShift].forEach(el => {
        el.addEventListener('input', requestRender);
        el.addEventListener('change', requestRender);
    });

    els.title.addEventListener('input', () => { els.titleDisplay.textContent = els.title.value; });
    els.ppfShape.addEventListener('change', () => {
        if(els.ppfShape.value === 'custom') els.customFormulaGroup.classList.remove('hidden');
        else els.customFormulaGroup.classList.add('hidden');
    });

    document.getElementById('btnDownload').addEventListener('click', () => {
        const link = document.createElement('a');
        link.download = (els.title.value || 'ppf') + '.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
    });

    function resizeCanvas() {
        const rect = container.getBoundingClientRect();
        canvas.width = rect.width * window.devicePixelRatio;
        canvas.height = rect.height * window.devicePixelRatio;
        ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        requestRender();
    }
    window.addEventListener('resize', resizeCanvas);

    function requestRender() {
        if (!renderRequested) {
            renderRequested = true;
            requestAnimationFrame(render);
        }
    }

    function hexToRgba(hex, alpha) {
        let r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    const getExpectedY = (x, max_x, max_y, shape, customStr) => {
        if (x < 0) return max_y;
        if (x > max_x) return 0;
        if (shape === 'straight') {
            return max_y - (max_y / max_x) * x;
        } else if (shape === 'curved') {
            return max_y * Math.sqrt(1 - Math.pow(x / max_x, 2));
        } else if (shape === 'custom') {
            try {
                const fn = new Function('x', 'maxX', 'maxY', `return ${customStr}`);
                let res = fn(x, max_x, max_y);
                return isNaN(res) ? 0 : res;
            } catch(e) { return 0; }
        }
    };

    const getStatus = (x, y, max_x, max_y, shape, customStr) => {
        if (x < 0 || y < 0) return "Invalid";
        const expectedY = getExpectedY(x, max_x, max_y, shape, customStr);
        const tolerance = max_y * 0.02; 
        
        if (x > max_x || y > expectedY + tolerance) return "Unattainable";
        if (y < expectedY - tolerance) return "Inefficient";
        return "Efficient";
    };

    // Drag Interaction Logic
    const getScreenX = (dataX) => canvasProj.padLeft + (dataX / canvasProj.maxData) * canvasProj.size;
    const getScreenY = (dataY) => canvasProj.padTop + canvasProj.size - (dataY / canvasProj.maxData) * canvasProj.size;
    const getDataX = (screenX) => ((screenX - canvasProj.padLeft) / canvasProj.size) * canvasProj.maxData;
    const getDataY = (screenY) => ((canvasProj.padTop + canvasProj.size - screenY) / canvasProj.size) * canvasProj.maxData;

    canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left);
        const mouseY = (e.clientY - rect.top);

        const aXScreen = getScreenX(parseFloat(els.ptAX.value)) / window.devicePixelRatio;
        const aYScreen = getScreenY(parseFloat(els.ptAY.value)) / window.devicePixelRatio;
        const bXScreen = getScreenX(parseFloat(els.ptBX.value)) / window.devicePixelRatio;
        const bYScreen = getScreenY(parseFloat(els.ptBY.value)) / window.devicePixelRatio;

        const distA = Math.hypot(mouseX - aXScreen, mouseY - aYScreen);
        const distB = Math.hypot(mouseX - bXScreen, mouseY - bYScreen);

        if (distA < 15) { isDragging = true; dragTarget = 'A'; }
        else if (distB < 15) { isDragging = true; dragTarget = 'B'; }
    });

    canvas.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const rect = canvas.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left) * window.devicePixelRatio;
        const mouseY = (e.clientY - rect.top) * window.devicePixelRatio;

        let gX = getDataX(mouseX);
        let gY = getDataY(mouseY);

        if (gX < 0) gX = 0;
        if (gY < 0) gY = 0;

        const baseMaxX = parseFloat(els.maxX.value) || 100;
        const baseMaxY = parseFloat(els.maxY.value) || 100;
        const curMaxX = baseMaxX * (1 + (parseFloat(els.shiftXNum.value) || 0) / 100);
        const curMaxY = baseMaxY * (1 + (parseFloat(els.shiftYNum.value) || 0) / 100);
        
        let expY = getExpectedY(gX, curMaxX, curMaxY, els.ppfShape.value, els.customEq.value);
        let snapDist = canvasProj.maxData * 0.05; // 5% snapping distance

        if (Math.abs(gY - expY) < snapDist) {
            gY = expY; // Snap to curve
        }

        if (dragTarget === 'A') {
            els.ptAX.value = gX.toFixed(1);
            els.ptAY.value = gY.toFixed(1);
        } else if (dragTarget === 'B') {
            els.ptBX.value = gX.toFixed(1);
            els.ptBY.value = gY.toFixed(1);
        }
        requestRender();
    });

    window.addEventListener('mouseup', () => { isDragging = false; dragTarget = null; });

    function render() {
        renderRequested = false;
        
        const baseMaxX = parseFloat(els.maxX.value) || 100;
        const baseMaxY = parseFloat(els.maxY.value) || 100;
        const sX = parseFloat(els.shiftXNum.value) || 0;
        const sY = parseFloat(els.shiftYNum.value) || 0;
        const shape = els.ppfShape.value;
        const customEq = els.customEq.value;

        const curMaxX = baseMaxX * (1 + sX / 100);
        const curMaxY = baseMaxY * (1 + sY / 100);

        const aX = parseFloat(els.ptAX.value) || 0;
        const aY = parseFloat(els.ptAY.value) || 0;
        const bX = parseFloat(els.ptBX.value) || 0;
        const bY = parseFloat(els.ptBY.value) || 0;

        const statusA = getStatus(aX, aY, curMaxX, curMaxY, shape, customEq);
        const statusB = getStatus(bX, bY, curMaxX, curMaxY, shape, customEq);
        
        els.statA.textContent = statusA;
        els.statB.textContent = statusB;
        
        const statusColors = {"Efficient": "#28a745", "Inefficient": "#f0ad4e", "Unattainable": "#d9534f", "Invalid": "#6c757d"};
        els.statA.style.color = statusColors[statusA] || "#333";
        els.statA.style.fontWeight = "bold";
        els.statB.style.color = statusColors[statusB] || "#333";
        els.statB.style.fontWeight = "bold";

        let diffX = bX - aX;
        let diffY = bY - aY;
        
        if (statusA === "Unattainable" || statusB === "Unattainable") {
            els.statGain.textContent = "N/A (Unattainable)";
            els.statLoss.textContent = "N/A (Unattainable)";
        } else {
            els.statGain.textContent = diffX > 0 ? `+${diffX.toFixed(1)} ${els.labelX.value}` : (diffY > 0 ? `+${diffY.toFixed(1)} ${els.labelY.value}` : "None");
            els.statLoss.textContent = diffX < 0 ? `${Math.abs(diffX).toFixed(1)} ${els.labelX.value}` : (diffY < 0 ? `${Math.abs(diffY).toFixed(1)} ${els.labelY.value}` : "None");
        }

        const w = canvas.width / window.devicePixelRatio;
        const h = canvas.height / window.devicePixelRatio;
        ctx.clearRect(0, 0, w, h);

        const padLeft = 60, padBottom = 60, padTop = 40, padRight = 40;
        const plotW = w - padLeft - padRight;
        const plotH = h - padTop - padBottom;

        // Uniform Scale Engine
        const maxDisplayData = Math.max(baseMaxX, curMaxX, aX, bX, baseMaxY, curMaxY, aY, bY) * 1.1;
        const size = Math.min(plotW, plotH);
        
        // Save to global projection for dragging
        canvasProj.padLeft = padLeft;
        canvasProj.padTop = padTop;
        canvasProj.size = size;
        canvasProj.maxData = maxDisplayData;

        const getX = (x) => padLeft + (x / maxDisplayData) * size;
        const getY = (y) => padTop + size - (y / maxDisplayData) * size;

        ctx.beginPath();
        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 1;
        ctx.font = '12px sans-serif';
        ctx.fillStyle = '#333';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';

        let tick = maxDisplayData / 10;
        for (let x = 0; x <= maxDisplayData; x += tick) {
            let px = getX(x);
            if (px > w - padRight + 1) continue;
            ctx.moveTo(px, padTop); ctx.lineTo(px, padTop + size);
            ctx.fillText(x.toFixed(0), px, padTop + size + 5);
        }

        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        for (let y = 0; y <= maxDisplayData; y += tick) {
            let py = getY(y);
            if (py < padTop - 1) continue;
            ctx.moveTo(padLeft, py); ctx.lineTo(padLeft + size, py);
            ctx.fillText(y.toFixed(0), padLeft - 5, py);
        }
        ctx.stroke();

        ctx.fillStyle = '#000';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(els.labelX.value, padLeft + size/2, padTop + size + 35);
        ctx.save();
        ctx.translate(15, padTop + size/2);
        ctx.rotate(-Math.PI/2);
        ctx.fillText(els.labelY.value, 0, 0);
        ctx.restore();

        ctx.font = 'bold 18px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(els.title.value, padLeft + size/2, 20);

        ctx.save();
        ctx.beginPath();
        ctx.rect(padLeft, padTop, size, size);
        ctx.clip();

        if (els.showShading.checked) {
            ctx.fillStyle = hexToRgba(els.colPPF.value, 0.1);
            ctx.beginPath();
            ctx.moveTo(getX(0), getY(0));
            for (let x = 0; x <= curMaxX; x += curMaxX / 100) {
                ctx.lineTo(getX(x), getY(getExpectedY(x, curMaxX, curMaxY, shape, customEq)));
            }
            ctx.lineTo(getX(curMaxX), getY(0));
            ctx.fill();
        }

        if (sX !== 0 || sY !== 0) {
            ctx.strokeStyle = els.colShift.value;
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(getX(0), getY(baseMaxY));
            for (let x = 0; x <= baseMaxX; x += baseMaxX / 100) {
                ctx.lineTo(getX(x), getY(getExpectedY(x, baseMaxX, baseMaxY, shape, customEq)));
            }
            ctx.stroke();
            ctx.setLineDash([]);
        }

        ctx.strokeStyle = els.colPPF.value;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(getX(0), getY(curMaxY));
        for (let x = 0; x <= curMaxX; x += curMaxX / 100) {
            ctx.lineTo(getX(x), getY(getExpectedY(x, curMaxX, curMaxY, shape, customEq)));
        }
        ctx.stroke();

        const drawPoint = (x, y, color, label) => {
            if (x < 0 || y < 0) return;
            
            ctx.strokeStyle = hexToRgba(color, 0.5);
            ctx.lineWidth = 1.5;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(getX(0), getY(y)); ctx.lineTo(getX(x), getY(y)); ctx.lineTo(getX(x), getY(0));
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(getX(x), getY(y), 8, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#000';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(label, getX(x) + 12, getY(y) - 12);
        };

        drawPoint(aX, aY, '#d9534f', 'A');
        drawPoint(bX, bY, '#5cb85c', 'B');

        if ((aX !== bX || aY !== bY) && statusA !== "Invalid" && statusB !== "Invalid") {
            const headlen = 10;
            const fromX = getX(aX);
            const fromY = getY(aY);
            const toX = getX(bX);
            const toY = getY(bY);
            const angle = Math.atan2(toY - fromY, toX - fromX);

            const dist = Math.sqrt(Math.pow(toX - fromX, 2) + Math.pow(toY - fromY, 2));
            if (dist > 25) {
                const startX = fromX + 12 * Math.cos(angle);
                const startY = fromY + 12 * Math.sin(angle);
                const endX = toX - 12 * Math.cos(angle);
                const endY = toY - 12 * Math.sin(angle);

                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.lineTo(endX - headlen * Math.cos(angle - Math.PI / 6), endY - headlen * Math.sin(angle - Math.PI / 6));
                ctx.moveTo(endX, endY);
                ctx.lineTo(endX - headlen * Math.cos(angle + Math.PI / 6), endY - headlen * Math.sin(angle + Math.PI / 6));
                ctx.stroke();
            }
        }

        ctx.restore();
    }

    setTimeout(resizeCanvas, 100);
</script>
</body>
</html>